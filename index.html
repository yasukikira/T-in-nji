<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CYBER PROTOCOL V7 [FINAL]</title>
    
    <style>
        :root { --primary: #00f3ff; --secondary: #ff0055; --bg: #050510; --panel-bg: rgba(0, 10, 20, 0.4); }
        
        body { 
            background-color: var(--bg);
            color: var(--primary); 
            font-family: "Courier New", Courier, monospace; 
            margin: 0; 
            height: 100vh; 
            width: 100vw;
            overflow: hidden; 
            user-select: none; 
        }

        /* --- FAILSAFE CSS BACKGROUND --- */
        #css-fallback {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0;
            background: 
                linear-gradient(rgba(0, 243, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 243, 255, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            perspective: 500px;
            transform-style: preserve-3d;
            animation: gridMove 20s linear infinite;
            display: none; 
        }
        #css-fallback::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 30%, var(--bg) 90%);
        }
        @keyframes gridMove { 0% { background-position: 0 0; } 100% { background-position: 0 500px; } }

        /* Canvas */
        #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; opacity: 0; transition: opacity 1s; }
        
        /* Overlays */
        .overlay-fx { position: fixed; top:0; left:0; width:100%; height:100%; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06)); background-size: 100% 2px, 3px 100%; z-index: 5; pointer-events: none; }
        .glitch-overlay { display: none; position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(255,0,0,0.1); z-index: 99; pointer-events: none; animation: flashWarn 0.2s infinite; }
        @keyframes flashWarn { 0%{opacity:0} 50%{opacity:0.3} 100%{opacity:0} }

        /* UI */
        #main-layout { display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; position: relative; z-index: 10; gap: 20px; }
        
        /* Side Panel: Hidden on Mobile, Visible on Desktop */
        .side-panel { 
            flex: 1; height: 80%; background: var(--panel-bg); border: 1px solid rgba(0,243,255,0.3); 
            display: none; /* Default Hidden (Mobile) */
            padding: 20px; clip-path: polygon(20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%, 0 20px); 
            transition: 0.3s; backdrop-filter: blur(5px); text-shadow: 0 0 5px #000; min-width: 200px;
        }
        
        /* Desktop Breakpoint */
        @media (min-width: 900px) { 
            .side-panel { display: block; } 
        }

        .console-wrapper { width: 100%; max-width: 500px; display: flex; flex-direction: column; align-items: center; perspective: 1000px; }
        
        .screen { background: var(--panel-bg); border: 1px solid var(--primary); width: 100%; padding: 30px 0; display: none; flex-direction: column; align-items: center; backdrop-filter: blur(8px); transition: transform 0.5s ease; box-shadow: 0 0 30px rgba(0,0,0,0.5); text-shadow: 0 0 2px #000; }
        .screen.visible { display: flex; }
        
        #grid-container { display: grid; gap: 8px; margin-bottom: 25px; transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .sabotage-tilt { transform: rotate(15deg) scale(0.9); border: 2px solid var(--secondary); padding: 10px; }
        .sabotage-invert { transform: rotate(-15deg) scale(0.9); filter: invert(1); }

        .cell { width: 60px; height: 60px; background: rgba(0, 243, 255, 0.1); border: 1px solid rgba(0, 243, 255, 0.5); cursor: pointer; transition: 0.1s; }
        .cell.active { background: #fff; box-shadow: 0 0 20px #fff; transform: scale(1.1); }
        .cell.error { background: var(--secondary); box-shadow: 0 0 20px var(--secondary); }

        button { background: rgba(0, 243, 255, 0.2); color: var(--primary); border: 1px solid var(--primary); padding: 10px 20px; cursor: pointer; font-weight: bold; margin-top: 10px; font-family:inherit; text-transform:uppercase; text-shadow: 0 0 5px var(--primary); }
        button:hover { background: var(--primary); color: #000; text-shadow:none; }
        input, textarea { background: rgba(0,0,0,0.7); border: 1px solid #555; color: #fff; padding: 10px; width: 80%; text-align: center; margin: 10px 0; font-family:inherit; font-size:1.1rem;}

        .hud-stat { font-size: 0.8rem; color: #aaa; margin-bottom: 5px; text-shadow: 1px 1px 0 #000; }
        .hud-val { font-size: 1.5rem; color: #fff; font-weight: bold; text-shadow: 0 0 10px var(--primary); }
    </style>
</head>
<body>
    <div id="css-fallback"></div>
    <div id="canvas-container"></div>
    <div class="overlay-fx"></div>
    <div class="glitch-overlay" id="danger-overlay"></div>

    <div id="main-layout">
        <div class="side-panel">
            <h3>SYS_DIAGNOSTICS</h3>
            <div id="sys-log" style="font-size:0.8rem; opacity:0.9; line-height:1.5;">
                > SYSTEM_READY<br>
                > AUDIO_ENGINE: ADAPTIVE<br>
                > NETWORK: SECURE<br>
            </div>
        </div>

        <div class="console-wrapper">
            <div style="width:100%; display:flex; justify-content:space-between; margin-bottom:10px; background:rgba(0,0,0,0.6); padding:10px; border:1px solid #333;">
                <div><div class="hud-stat">LEVEL</div><div class="hud-val" id="level-display">01</div></div>
                <div style="text-align:right;"><div class="hud-stat">PROGRESS</div><div class="hud-val" id="round-display">1/6</div></div>
            </div>

            <div id="game-screen" class="screen visible">
                <h2 id="center-msg" style="letter-spacing:3px;">READY</h2>
                <div id="grid-container"></div>
                <button id="start-btn">INITIALIZE</button>
            </div>

            <div id="reward-screen" class="screen">
                <h2 style="color:var(--secondary)">CONNECTION LOST</h2>
                <p>LEVELS CLEARED: <span id="final-level" style="font-weight:bold; color:#fff">0</span></p>
                <input type="text" id="discord-id" placeholder="DISCORD ID">
                <div id="verify-error" style="color:var(--secondary); font-size:0.8rem;"></div>
                <button id="gen-btn">GENERATE HASH</button>
                <button id="restart-btn" style="border:none; background:none; font-size:0.8rem; color:#888;">RETRY</button>
            </div>

            <div id="code-screen" class="screen">
                <h2>KEY GENERATED</h2>
                <textarea id="output-code" rows="4" readonly></textarea>
                <button id="copy-btn" style="margin-bottom:10px; border-color:#fff;">COPY TO CLIPBOARD</button>
                <button id="new-session-btn">NEW SESSION</button>
            </div>
        </div>

        <div class="side-panel">
            <h3>ENV_STATUS</h3>
            <div style="font-size:0.8rem; opacity:0.9;">
                STABILITY: <span id="env-stab">100%</span><br>
                THREAT_LEVEL: <span id="env-threat">NONE</span>
            </div>
        </div>
    </div>

    <script type="module">
        const State = {
            threeLoaded: false,
            discordLoaded: false,
            gameReady: true
        };

        // ==========================================
        // 1. DYNAMIC LOADER
        // ==========================================
        async function loadModules() {
            try {
                // Try Skypack (ESM Optimized) first
                let THREE = await import('https://cdn.skypack.dev/three@0.136.0');
                if (!THREE || !THREE.Scene) throw new Error("Skypack failed");
                window.THREE = THREE;
                State.threeLoaded = true;
                initVisuals(THREE);
            } catch (e) {
                try {
                    // Fallback to Unpkg Module
                    let THREE = await import('https://unpkg.com/three@0.136.0/build/three.module.js');
                    window.THREE = THREE;
                    State.threeLoaded = true;
                    initVisuals(THREE);
                } catch (e2) {
                    // Critical Failure: Enable CSS Grid
                    document.getElementById('css-fallback').style.display = 'block';
                }
            }

            try {
                let SDK = await import('https://cdn.skypack.dev/@discord/embedded-app-sdk');
                const { DiscordSDK } = SDK;
                // !!! REPLACE CLIENT ID !!!
                const discordSdk = new DiscordSDK("1264837329886117959");
                await discordSdk.ready();
            } catch (e) {
                console.warn("SDK Offline");
            }
        }

        // ==========================================
        // 2. VISUAL ENGINE
        // ==========================================
        const Visuals = {
            scene: null, camera: null, renderer: null, terrain: null, particles: null,
            targetSpeed: 0.05, currentSpeed: 0.05, shakeIntensity: 0, glitchMode: false,
            
            setMode: (isBoss) => {
                // Triggered if level % 5 == 0
                if (!State.threeLoaded) {
                     const fallback = document.getElementById('css-fallback');
                     if(isBoss) fallback.style.filter = "hue-rotate(300deg) contrast(1.2)";
                     else fallback.style.filter = "none";
                     return;
                }

                if(!Visuals.terrain) return;
                const mat = Visuals.terrain.material;
                if(isBoss) {
                    // BOSS MODE VISUALS (Red, Shake, Fast)
                    Visuals.glitchMode = true; Visuals.targetSpeed = 0.35; Visuals.shakeIntensity = 0.6;
                    mat.color.setHex(0xff0055); Visuals.pMat.color.setHex(0xff0055);
                    mat.opacity = 0.6; Visuals.scene.fog.density = 0.005;
                    Visuals.renderer.setClearColor(0x1a0005);
                    document.getElementById('danger-overlay').style.display = 'block';
                    document.getElementById('env-threat').innerText = "CRITICAL"; document.getElementById('env-threat').style.color = "red";
                } else {
                    // NORMAL MODE
                    Visuals.glitchMode = false; Visuals.targetSpeed = 0.05; Visuals.shakeIntensity = 0;
                    mat.color.setHex(0x00f3ff); Visuals.pMat.color.setHex(0xffffff);
                    mat.opacity = 0.3; Visuals.scene.fog.density = 0.002;
                    Visuals.renderer.setClearColor(0x050510);
                    Visuals.camera.position.x = 0; Visuals.camera.rotation.z = 0; 
                    document.getElementById('danger-overlay').style.display = 'none';
                    document.getElementById('env-threat').innerText = "NONE"; document.getElementById('env-threat').style.color = "#0aa";
                }
            }
        };

        function initVisuals(THREE) {
            const container = document.getElementById("canvas-container");
            const w = window.innerWidth;
            const h = window.innerHeight;

            Visuals.scene = new THREE.Scene();
            Visuals.scene.fog = new THREE.FogExp2(0x050510, 0.002);

            Visuals.camera = new THREE.PerspectiveCamera(75, w/h, 0.1, 1000);
            Visuals.camera.position.set(0, 10, 50);
            Visuals.camera.rotation.x = -0.2;

            Visuals.renderer = new THREE.WebGLRenderer({ alpha: false, antialias: true, powerPreference: "high-performance" });
            Visuals.renderer.setSize(w, h);
            Visuals.renderer.setClearColor(0x050510);
            Visuals.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(Visuals.renderer.domElement);
            container.style.opacity = 1;

            const geo = new THREE.PlaneGeometry(200, 200, 50, 50);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00f3ff, wireframe: true, transparent: true, opacity: 0.3 });
            Visuals.terrain = new THREE.Mesh(geo, mat);
            Visuals.terrain.rotation.x = -Math.PI / 2;
            Visuals.scene.add(Visuals.terrain);

            const pGeo = new THREE.BufferGeometry();
            const pPos = new Float32Array(1500 * 3);
            for(let i=0; i<4500; i++) pPos[i] = (Math.random()-0.5)*200;
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
            Visuals.pMat = new THREE.PointsMaterial({ size: 0.5, color: 0xffffff });
            Visuals.particles = new THREE.Points(pGeo, Visuals.pMat);
            Visuals.scene.add(Visuals.particles);

            function animate() {
                requestAnimationFrame(animate);
                Visuals.currentSpeed += (Visuals.targetSpeed - Visuals.currentSpeed) * 0.05;
                const pos = Visuals.terrain.geometry.attributes.position;
                const arr = pos.array;
                let time = Date.now() * 0.001;
                for(let i=0; i < arr.length; i+=3) {
                    if(Visuals.glitchMode) arr[i+2] = Math.sin(arr[i]/5 + time*5) * 5 + (Math.random()-0.5)*2; 
                    else arr[i+2] = Math.sin(arr[i]/10 + time*2) * 2 + Math.cos(arr[i+1]/10 + time) * 2;
                }
                pos.needsUpdate = true;
                Visuals.terrain.position.z = (time * 10 * Visuals.currentSpeed * 10) % 5;
                Visuals.particles.rotation.y = time * 0.1;
                if(Visuals.shakeIntensity > 0) {
                    Visuals.camera.position.x = (Math.random() - 0.5) * Visuals.shakeIntensity;
                    Visuals.camera.position.y = 10 + (Math.random() - 0.5) * Visuals.shakeIntensity;
                    Visuals.camera.rotation.z = Math.sin(time*2) * 0.05; 
                }
                Visuals.renderer.render(Visuals.scene, Visuals.camera);
            }
            animate();

            window.addEventListener('resize', () => {
                Visuals.camera.aspect = window.innerWidth / window.innerHeight;
                Visuals.camera.updateProjectionMatrix();
                Visuals.renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // ==========================================
        // 3. GAME LOGIC (Independent)
        // ==========================================
        (() => {
            let state = { l: 1, r: 1, seq: [], input: [], locked: true, sz: 3 };
            const els = {
                grid: document.getElementById('grid-container'),
                msg: document.getElementById('center-msg'),
                lvl: document.getElementById('level-display'),
                rnd: document.getElementById('round-display')
            };

            const Audio = {
                ctx: null, masterGain: null, compressor: null,
                bpm: 120, nextNoteTime: 0, beatCount: 0, isPlaying: false, currentChord: 0, timerID: null,
                progression: [146.83, 174.61, 130.81, 196.00], 
                scaleIntervals: [1, 1.2, 1.33, 1.5, 1.6, 2, 2.4, 2.66, 3.0, 3.2, 4, 4.8, 5.33, 6.0, 6.4], 

                initCtx: () => { 
                    if(!Audio.ctx) {
                        try {
                            const Ctx = window.AudioContext || window.webkitAudioContext;
                            Audio.ctx = new Ctx();
                            Audio.masterGain = Audio.ctx.createGain();
                            Audio.compressor = Audio.ctx.createDynamicsCompressor();
                            Audio.masterGain.gain.value = 0.8; 
                            Audio.compressor.threshold.value = -20;
                            Audio.compressor.knee.value = 40;
                            Audio.compressor.ratio.value = 12;
                            Audio.masterGain.connect(Audio.compressor);
                            Audio.compressor.connect(Audio.ctx.destination);
                        } catch(e) {}
                    }
                },

                startMusic: () => {
                    Audio.initCtx();
                    if (Audio.ctx && Audio.ctx.state === 'suspended') Audio.ctx.resume();
                    if(Audio.isPlaying) return;
                    Audio.isPlaying = true;
                    Audio.nextNoteTime = Audio.ctx.currentTime;
                    Audio.scheduler();
                },
                
                stopMusic: () => { Audio.isPlaying = false; clearTimeout(Audio.timerID); },

                scheduler: () => {
                    if(!Audio.isPlaying) return;
                    while (Audio.nextNoteTime < Audio.ctx.currentTime + 0.1) {
                        Audio.playTick(Audio.nextNoteTime);
                        Audio.nextNoteTime += (60 / Audio.bpm) / 4;
                    }
                    Audio.timerID = setTimeout(Audio.scheduler, 25);
                },

                playTick: (time) => {
                    const sixteenth = Audio.beatCount % 16;
                    const bar = Math.floor(Audio.beatCount / 16);
                    if(sixteenth === 0 && bar % 4 === 0) Audio.currentChord = (Audio.currentChord + 1) % Audio.progression.length;
                    const rootFreq = Audio.progression[Audio.currentChord];
                    
                    // --- BOSS LOGIC: Every 5 levels ---
                    const isBoss = (state.l % 5 === 0);
                    const level = state.l;
                    
                    // Atmosphere
                    if (sixteenth === 0) { 
                        const osc = Audio.ctx.createOscillator(); const g = Audio.ctx.createGain();
                        osc.type = 'triangle'; osc.frequency.value = rootFreq * 2;
                        g.gain.setValueAtTime(0, time); g.gain.linearRampToValueAtTime(0.2, time + 0.5); g.gain.linearRampToValueAtTime(0, time + 2.0);
                        const filter = Audio.ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 600;
                        osc.connect(filter); filter.connect(g); g.connect(Audio.masterGain); osc.start(time); osc.stop(time + 2.0);
                    }
                    // Pulse
                    if (sixteenth % 4 === 0) {
                         const osc = Audio.ctx.createOscillator(); const g = Audio.ctx.createGain();
                         osc.type = 'square'; osc.frequency.value = 2000;
                         g.gain.setValueAtTime(0.05, time); g.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
                         const hpf = Audio.ctx.createBiquadFilter(); hpf.type = 'highpass'; hpf.frequency.value = 1000;
                         osc.connect(hpf); hpf.connect(g); g.connect(Audio.masterGain); osc.start(time); osc.stop(time + 0.05);
                    }
                    // Kick & Bass
                    if (sixteenth % 4 === 0) { 
                        const osc = Audio.ctx.createOscillator(); const g = Audio.ctx.createGain();
                        osc.frequency.value = 60; g.gain.setValueAtTime(1.0, time); g.gain.exponentialRampToValueAtTime(0.001, time + 0.2);
                        osc.connect(g); g.connect(Audio.masterGain); osc.start(time); osc.stop(time + 0.2);

                        const bOsc = Audio.ctx.createOscillator(); const bG = Audio.ctx.createGain();
                        bOsc.type = 'sawtooth'; bOsc.frequency.value = (rootFreq / 4) + (level > 15 ? 5 : 0);
                        const filt = Audio.ctx.createBiquadFilter(); filt.type = 'lowpass'; filt.frequency.value = isBoss ? 800 : (400 + (level*10)); 
                        bG.gain.setValueAtTime(0, time); bG.gain.linearRampToValueAtTime(0.4, time + 0.1); bG.gain.linearRampToValueAtTime(0, time + 0.25);
                        bOsc.connect(filt); filt.connect(bG); bG.connect(Audio.masterGain); bOsc.start(time); bOsc.stop(time + 0.3);
                    }
                    // Snare
                    if (level >= 5 && (sixteenth % 8 === 4)) { 
                        const n = Audio.ctx.createBufferSource();
                        const buffer = Audio.ctx.createBuffer(1, Audio.ctx.sampleRate * 0.1, Audio.ctx.sampleRate);
                        const data = buffer.getChannelData(0);
                        for (let i = 0; i < buffer.length; i++) data[i] = (Math.random() * 2 - 1);
                        n.buffer = buffer; const nG = Audio.ctx.createGain();
                        nG.gain.setValueAtTime(0.3, time); nG.gain.exponentialRampToValueAtTime(0.001, time + 0.1);
                        const bpf = Audio.ctx.createBiquadFilter(); bpf.type = 'bandpass'; bpf.frequency.value = 1000;
                        n.connect(bpf); bpf.connect(nG); nG.connect(Audio.masterGain); n.start(time);
                    }
                    // Hats
                    const hatInterval = level >= 10 ? 2 : 4; 
                    if (level >= 3 && (sixteenth % hatInterval === 0) && sixteenth % 4 !== 0) { 
                        const n = Audio.ctx.createBufferSource();
                        const buffer = Audio.ctx.createBuffer(1, Audio.ctx.sampleRate * 0.05, Audio.ctx.sampleRate);
                        const data = buffer.getChannelData(0);
                        for (let i = 0; i < buffer.length; i++) data[i] = Math.random() * 2 - 1;
                        n.buffer = buffer; const nG = Audio.ctx.createGain(); nG.gain.value = 0.1;
                        const hpf = Audio.ctx.createBiquadFilter(); hpf.type = 'highpass'; hpf.frequency.value = 5000;
                        n.connect(hpf); hpf.connect(nG); nG.connect(Audio.masterGain); n.start(time);
                    }
                    // Arp
                    if ((state.r >= 5 || isBoss) && sixteenth % 2 === 0) {
                        const osc = Audio.ctx.createOscillator(); const g = Audio.ctx.createGain();
                        osc.type = 'triangle'; osc.frequency.value = rootFreq * Audio.scaleIntervals[sixteenth % 5] * 2; 
                        g.gain.setValueAtTime(0.1, time); g.gain.exponentialRampToValueAtTime(0.001, time + 0.1);
                        osc.connect(g); g.connect(Audio.masterGain); osc.start(time); osc.stop(time + 0.1);
                    }
                    Audio.beatCount++;
                },

                playGameNote: (gridIndex) => {
                    Audio.initCtx();
                    const rootFreq = Audio.progression[Audio.currentChord];
                    const degree = Audio.scaleIntervals[gridIndex % Audio.scaleIntervals.length];
                    const freq = rootFreq * degree * 2; 

                    const osc = Audio.ctx.createOscillator(); const g = Audio.ctx.createGain();
                    osc.type = state.l < 5 ? 'square' : 'sawtooth';
                    osc.frequency.setValueAtTime(freq, Audio.ctx.currentTime);
                    g.gain.setValueAtTime(0.15, Audio.ctx.currentTime);
                    g.gain.exponentialRampToValueAtTime(0.001, Audio.ctx.currentTime + 0.3);
                    osc.connect(g); g.connect(Audio.masterGain);
                    osc.start(); osc.stop(Audio.ctx.currentTime + 0.3);

                    if(state.l >= 15) {
                        const osc2 = Audio.ctx.createOscillator(); const g2 = Audio.ctx.createGain();
                        osc2.type = 'sawtooth'; osc2.frequency.setValueAtTime(freq * 1.25, Audio.ctx.currentTime); 
                        g2.gain.setValueAtTime(0.1, Audio.ctx.currentTime); g2.gain.exponentialRampToValueAtTime(0.001, Audio.ctx.currentTime + 0.3);
                        osc2.connect(g2); g2.connect(Audio.masterGain); osc2.start(); osc2.stop(Audio.ctx.currentTime + 0.3);
                    }
                },

                playWin: () => {
                    Audio.initCtx();
                    const now = Audio.ctx.currentTime;
                    const rootFreq = Audio.progression[Audio.currentChord]; 
                    [1, 1.25, 1.5, 2].forEach((interval, i) => {
                        const o = Audio.ctx.createOscillator(); const g = Audio.ctx.createGain();
                        o.type = 'triangle'; o.frequency.value = rootFreq * interval * 2; 
                        g.gain.setValueAtTime(0, now); g.gain.linearRampToValueAtTime(0.2, now + 0.1 + (i*0.05));
                        g.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
                        o.connect(g); g.connect(Audio.masterGain); o.start(now); o.stop(now + 2.0);
                    });
                },

                fail: () => {
                    Audio.initCtx();
                    const o = Audio.ctx.createOscillator(); const g = Audio.ctx.createGain();
                    o.type = 'sawtooth'; o.frequency.value = 60; o.frequency.linearRampToValueAtTime(40, Audio.ctx.currentTime + 0.3);
                    g.gain.value = 0.5; g.gain.exponentialRampToValueAtTime(0.001, Audio.ctx.currentTime + 0.3);
                    o.connect(g); g.connect(Audio.masterGain); o.start(); o.stop(Audio.ctx.currentTime + 0.3);
                }
            };

            const resetGrid = (size) => {
                els.grid.innerHTML = '';
                els.grid.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
                state.sz = size;
                for(let i=0; i<size*size; i++) {
                    let d = document.createElement('div');
                    d.className = 'cell';
                    d.onmousedown = () => handleInput(i);
                    els.grid.appendChild(d);
                }
            };

            const triggerSabotage = () => {
                const isBoss = (state.l % 5 === 0);
                Visuals.setMode(isBoss);
                Audio.bpm = 120 + Math.min(40, Math.floor(state.l / 5) * 5);
                if(isBoss) Audio.bpm += 20; 

                els.grid.classList.remove('sabotage-tilt', 'sabotage-invert');
                if(isBoss) {
                    els.msg.innerText = "⚠️ SYSTEM FAILURE ⚠️"; els.msg.style.color = "red";
                    if(Math.random() > 0.5) els.grid.classList.add('sabotage-tilt');
                    else els.grid.classList.add('sabotage-invert');
                } else {
                    els.msg.innerText = "OBSERVE"; els.msg.style.color = "#00f3ff";
                }
            };

            const nextRound = () => {
                state.input = []; state.locked = true;
                if(state.l >= 5 && state.sz < 4) resetGrid(4);
                if(state.l >= 15 && state.sz < 5) resetGrid(5);
                els.lvl.innerText = state.l.toString().padStart(2, '0');
                els.rnd.innerText = `${state.r}/6`;
                triggerSabotage();
                state.seq.push(Math.floor(Math.random() * (state.sz * state.sz)));
                let speed = Math.max(150, 600 - (state.l * 20));
                setTimeout(() => playSeq(speed), 800);
            };

            const playSeq = async (speed) => {
                for(let id of state.seq) {
                    let c = els.grid.children[id];
                    if(c) c.classList.add('active');
                    Audio.playGameNote(id); 
                    await new Promise(r => setTimeout(() => {
                        if(c) c.classList.remove('active');
                        setTimeout(r, speed/2);
                    }, speed/2));
                }
                state.locked = false; 
                if(!(state.l % 5 === 0)) els.msg.innerText = "REPEAT";
            };

            const handleInput = (id) => {
                if(state.locked) return;
                let c = els.grid.children[id];
                c.classList.add('active');
                setTimeout(()=>c.classList.remove('active'), 150);
                Audio.playGameNote(id); 
                state.input.push(id);
                if(state.input[state.input.length-1] !== state.seq[state.input.length-1]) {
                    fail(); return;
                }
                if(state.input.length === state.seq.length) {
                    state.locked = true;
                    if(state.r >= 6) {
                        state.l++; state.r = 1; state.seq = [];
                        Audio.playWin(); 
                        els.msg.innerText = "UPLOAD COMPLETE";
                        setTimeout(nextRound, 2000); 
                    } else {
                        state.r++;
                        setTimeout(nextRound, 400);
                    }
                }
            };

            const fail = () => {
                state.locked = true;
                Audio.fail();
                document.querySelectorAll('.cell').forEach(c => c.classList.add('error'));
                Visuals.setMode(false);
                setTimeout(() => {
                    document.getElementById('game-screen').classList.remove('visible');
                    document.getElementById('reward-screen').classList.add('visible');
                    document.getElementById('final-level').innerText = Math.max(0, state.l - 1);
                }, 1000);
            };
            
            const softReset = () => {
                state = { l: 1, r: 1, seq: [], input: [], locked: true, sz: 3 };
                document.getElementById('reward-screen').classList.remove('visible');
                document.getElementById('code-screen').classList.remove('visible');
                document.getElementById('game-screen').classList.add('visible');
                document.getElementById('start-btn').style.display = 'block';
                document.getElementById('verify-error').innerText = "";
                document.getElementById('discord-id').value = "";
                Visuals.setMode(false);
                Audio.bpm = 120;
                resetGrid(3);
                els.lvl.innerText = "01"; els.rnd.innerText = "1/6"; els.msg.innerText = "READY";
            }

            document.getElementById('start-btn').onclick = () => {
                document.getElementById('start-btn').style.display = 'none';
                Audio.startMusic();
                resetGrid(3); nextRound();
            };
            document.getElementById('restart-btn').onclick = softReset;
            document.getElementById('new-session-btn').onclick = softReset;

            // ==========================================
            // FIX START: CORRECTED ENCODER LOGIC
            // ==========================================
            document.getElementById('gen-btn').onclick = () => {
                const uid = document.getElementById('discord-id').value.trim();
                const lvl = state.l - 1;
                const err = document.getElementById('verify-error');
                
                if(lvl < 1) { err.innerText = "INSUFFICIENT DATA"; return; }
                if(uid.length < 2) { err.innerText = "INVALID ID"; return; }
                
                // Matches main.py expectations: UID :: LEVEL :: NONCE :: DATE :: SALT
                const nonce = Math.random().toString(36).substring(7);
                const salt = "CYBER_TRIVIA_SECRET_KEY_99";
                const rawString = `${uid}::${lvl}::${nonce}::${Date.now()}::${salt}`;
                const payload = btoa(rawString);

                document.getElementById('reward-screen').classList.remove('visible');
                document.getElementById('code-screen').classList.add('visible');
                document.getElementById('output-code').value = payload;
            };

            // COPY BUTTON LOGIC
            document.getElementById('copy-btn').onclick = () => {
                const copyText = document.getElementById("output-code");
                copyText.select();
                copyText.setSelectionRange(0, 99999);
                navigator.clipboard.writeText(copyText.value).then(() => {
                    const btn = document.getElementById('copy-btn');
                    const originalText = btn.innerText;
                    btn.innerText = "COPIED!";
                    btn.style.background = "#fff";
                    btn.style.color = "#000";
                    setTimeout(() => {
                        btn.innerText = originalText;
                        btn.style.background = "";
                        btn.style.color = "";
                    }, 2000);
                });
            };
            // ==========================================
            // FIX END
            // ==========================================
        })();

        loadModules();
    </script>
</body>
</html>